#include <iostream>
#include <cmath>

using namespace std;

double f(double);
double fp(double);
double bisection(double, double);
double falsia(double, double);
double newton(double);
double sieczne(double, double);

double lagrange(double, double*, double*, int);

double newtonInter(double, double*, double*, int);

double hermite(double, double*, double*, double*, int);

int main() {
	double x[] = { 1,4,9,16,25 };
	double fx[] = { 1,2,3,4,5 };
	double df[5] = { 0,0,0,0,0 };

	/*for (int i = 1; i <= 25; i++)
	{
		cout <<i<<". "<< hermite(i, x, fx, df, 3) << endl;
	}*/

	cout << hermite(25, x, fx, df, 5) << endl;

	system("pause");
	return 0;
}

double f(double x) {
	return 2 * pow(x, 2) + 3 * x - 4;
}

double fp(double x) {
	return 4 * x + 3;
}

double bisection(double a, double b) {
	double x1, epsilon = 0.1, residuum = 0.1;

	while (abs(a - b) > epsilon) {
		x1 = (a + b) / 2;

		if (f(x1) <= residuum)
			break;
		else if (f(x1) * f(a) < 0)
			b = x1;
		else
			a = x1;
	}

	return (a + b) / 2;
}

double falsia(double a, double b) {
	double epsilon = 0.1, residuum = 0.1, fa = f(a), fb = f(b), x1 = a, x0 = b, f0;

	/*if (fa * fb > 0) {
		cout << "error" << endl;
		return 0;
	}*/

	while (abs(x1 - x0) > epsilon) {
		x1 = x0;
		x0 = a - fa * (b - a) / (fb - fa);
		f0 = f(x0);
		if (abs(f0) < residuum) 
			break;
		else if (fa * f0 < 0) {
			b = x0;
			fb = f0;
		}
		else {
			a = x0;
			fa = f0;
		}
	}

	return x0;
}

double newton(double x0) {
	double epsilon = 0.1, residuum = 0.1, x1 = x0 - 1, f0 = f(x0), f1;
	int i = 64;

	while (/*i &&*/ abs(x1 - x0) > epsilon && abs(f0) > residuum) {
		f1 = fp(x0);
		/*if (abs(f1) < residuum) {
			cout << "error" << endl;
			return 0;
		}*/

		x1 = x0;
		x0 = x0 - f0 / f1;
		f0 = f(x0);
	}

	return x0;
}

double sieczne(double x1, double x2) {
	double epsilon = 0.1, residuum = 0.1, f1 = f(x1), f2 = f(x2), x0, f0;

	while (abs(x1 - x2) > epsilon) {
		x0 = x1 - f1 * (x1 - x2) / (f1 - f2);
		f0 = f(x0);
		if (abs(f0) < residuum) break;
		x2 = x1;
		f2 = f1;
		x1 = x0;
		f1 = f0;
	}

	return x0;
}


double lagrange(double X, double* x, double* fx, int n)
{
	double ret = 0;

	for (int i = 0; i < n; i++)
	{
		double factor = 1;

		for (int j = 0; j < n; j++)
		{
			if (j != i)
			{
				factor *= (X - x[j]) / (x[i] - x[j]);
			}
		}

		ret += fx[i] * factor;
	}

	return ret;
}

double newtonInter(double X, double* x, double* fx, int n)
{
	double ret = 0, factor;
	int i, j;

	for (i = 0; i < n - 1; i++)
	{
		for (j = n - 1; j > i; j--)
		{
			fx[j] = (fx[j] - fx[j - 1]) / (x[j] - x[j - i - 1]);
		}
	}

	for (i = n - 1; i >= 0; i--)
	{
		factor = 1;
		
		for (j = 0; j < i; j++)
		{
			factor *= (X - x[j]);
		}

		factor *= fx[j];
		ret += factor;
	}

	return ret;
}

double hermite(double X, double* t_x, double* t_fx, double* t_df, int n)
{
	double* x = new double[n];
	double* fx = new double[n];
	double* df = new double[n];
	for (int i = 0; i < n; i++)
	{
		x[i] = t_x[i];
		fx[i] = t_fx[i];
		df[i] = t_df[i];
	}


	for (int i = 1; i < n; i++)
	{
		if (x[i] == x[i - 1])
			df[i] = df[i - 1] + 1;
		else
			df[i] = 0;
	}

	for (int i = 1; i < n; i++)
	{
		for (int j = n - 1; j >= i; j--)
		{
			if (df[j] == 0)
				fx[j] = (fx[j] - fx[((int)(j - 1 - df[j - 1]))]) / (x[j] - x[j - i]);
			else
			{
				fx[j] /= (double)i;
				df[j]--;
			}
		}
	}

	for (int j = n - 1; j >= 0; j--)
	{
		for (int i = j; i < n - 1; i++)
		{
			fx[i] = fx[i] - fx[i + 1] * x[j];
		}
	}

	/*cout << "W(x) = ";
	for (int i = 0; i < n; i++)
	{
		if (i == 0)
			cout << fx[i];
		else if (i == 1)
			cout << fx[i] << 'x';
		else
			cout << fx[i] << "x^" << i;
		if (i != n - 1)
			cout << " + ";
	}*/

	double ret = 0;

	for (int i = 0; i < n; i++)
	{
		ret += fx[i] * pow(X, i);
	}

	return ret;
}
